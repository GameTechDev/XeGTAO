Add back to README.md:
" For more detail and a step-by-step integration guide please refer to the [integration guide](/INTEGRATION.md). "

# XeGTAO Integration Guide

This is just a horrible bunch of notes; will get updated before release.

This document intends to provide a brief guide on integrating GTAO into an existing application.
GTAO is a two and a half file shipping solution; the implementation is contained in GTAO.hlsli and GTAO.h, and there is a vaGTAO.hlsl which gives an example of how to interface GTAO with an existing framework, in this case the vanilla demo framework.
GTAO.h is included from both cpp side and hlsl side. It defines global compile time constants such as number of depth mip levels and the number of compute threads. It defines the structure of constant buffer GTAOConstants including viewport size, effect radius and falloff, denoise count. It also defines GTAOSettings that control how GTAO is computed including the radius multiplier, falloff range, and a thickness heuristic. These switches are mapped to imgui settings, and this file also contains the definition of the function that maps settings to imgui calls. Also note that if the app supports run time shader recompilation, then you can simply change one of these settings in the GUI and recompile.
First step just grab files, and add to existing project. Then add code to add GTAO settings to imgui. If you're using imgui as your interface code this should be a straight drag and drop (assuming the imgui versions are close/recent). If you have a different GUI for your app you will need to adjust appropriately.

GTAO is currently written as three passes so there are three compute shader entry points: CS_PrefilterDepths, CS_GTAO, and CS_Denoise. These are declared in the vaGTAO.hlsl interface file.

CS_PrefilterDepths takes as input the depth buffer, and outputs a filtered, mip-mapped set of depths. 
This is a view to the depth buffer. GTAO can work with float or fp16 depth buffers, see notes below.
```
Texture2D<float>            g_sourceDepth       : register( t0 );   
```
The output of CS_PrefilterDepths is a single mip-mapped resource containing prefiltered depths in viewspace.
```
RWTexture2D<float>          g_outputDepth       : register( u0 );
RWTexture2D<float>          g_outputDepthMIP1   : register( u1 );
RWTexture2D<float>          g_outputDepthMIP2   : register( u2);
RWTexture2D<float>          g_outputDepthMIP3   : register( u3 );
RWTexture2D<float>          g_outputDepthMIP4   : register( u4 );
```

CS_GTAO is the compute shader that computes the ambient occlusion. CS_GTAO takes the mip-mapped prefiltered depths as input, as well as the normals, and a blue noise texture resource. It outputs a g_sourceVis resource containing the computed visibility, and sourceEdges used as input for the denoiser.
Normals can be generated by GTAO if needed, otherwise the app is expected to provide them. GTAO can handle provided normals in world space or viewspace. `Texture2D<uint>             g_sourceNormalmap   : register( t1 );`

The output visibility of GTAO is written to this resource. `RWTexture2D<unorm float>    g_outputFinal       : register( u0 );`

If needed for debugging, GTAO can output the edges it detected. `RWTexture2D<unorm float>    g_outputEdges       : register( u1 );`

This is a blue noise texture resource provided to perturb screen space slices and steps.
```Texture2D                   g_sourceBlueNoise   : register( t5 );   ```

Notes on noise:
The current implementation of GTAO uses a blue noise texture to perturb the screen space slice and steps along the slice. Note that this is not obligatory, but works well. Another possibility is to use a screen hash. We have included both here for your comparisons.

CSDenoise is the final pass, which does denoising. This takes the source visibility and source edges computed by GTAO, and denoises the result. Note in applications with an existing denoising pass this might be unnecessary. Also, a temporal accumulation is also highly recommended.
```
Texture2D                   g_sourceVis         : register( t0 );   
Texture2D                   g_sourceEdges       : register( t1 );   
```
There are several switches to shader compilation that control different GTAO options.
* GTAO_GENERATE_NORMALS - if defined, then GTAO will generate normals instead of expecting the app to provide normals
* GTAO_FP16_DEPTHS - if defined, GTAO will process a 16-depth buffer. This will provide performance benefits at some cost to quality.
* GTAO_SHOW_DEBUG_VIZ  - TBD - do we leave this in? it requires app support that most apps likely won't have.
* GTAO_SHOW_NORMALS - this is a debug switch to the shader. If defined, GTAO will output a debugImage and write the normals into it.
* GTAO_SHOW_EDGES - this is a debug switch. If defined, GTAO will output a debugImage and write the detected edges into it.
* GTAO_DEFINE_EXTERNAL_SAMPLERS - GTAO uses two samplers. These can be defined statically in the shader, or passed in as macros that define the samplers.
    * `SamplerState  g_samplerLinearClamp : register( s1 );	`
    * `SamplerState  g_samplerPointClamp : register( s2 );`


## Thread groups and Dispatch sizes
Thread groups sizes are defined in GTAO.h, which is included from both the c++ side as well as the shader side. CS_PrefilterDepths takes a thread group of size (GTAO_NUMTHREADS_X, GTAO_NUMTHREADS_Y, 1). It expects to launch one compute shader thread per pixel, so the call to dispatch could look like this:
int width = int(m_Viewport.Width);
int height = int(m_Viewport.Height);
m_pCommandList->Dispatch((width + GTAO_NUMTHREADS_X - 1) / GTAO_NUMTHREADS_X, (height + GTAO_NUMTHREADS_Y - 1) / GTAO_NUMTHREADS_Y, 1);

CS_GTAO takes a thread group of size (GTAO_NUMTHREADS_X, GTAO_NUMTHREADS_Y, 1). It expects to launch one compute shader thread per pixel, so the call to dispatch is the same as above:
m_pCommandList->Dispatch((width + GTAO_NUMTHREADS_X - 1) / GTAO_NUMTHREADS_X, (height + GTAO_NUMTHREADS_Y - 1) / GTAO_NUMTHREADS_Y, 1);

CSDenoise takes a thread group size of (GTAO_DENOISE_EXTERIOR_THREADS_X, GTAO_DENOISE_EXTERIOR_THREADS_Y, 1).
The call to dispatch looks like this:
m_pCommandList->Dispatch((width + GTAO_DENOISE_INTERIOR_X - 1) / GTAO_DENOISE_INTERIOR_X, (height + GTAO_DENOISE_INTERIOR_Y - 1) / GTAO_DENOISE_INTERIOR_Y, 1);
